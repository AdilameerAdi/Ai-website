export const exportService = {
  // Export proposal as PDF
  exportProposalToPDF: async (proposal) => {
    try {
      const { jsPDF } = await import('jspdf');
      const doc = new jsPDF();

      // Header
      doc.setFontSize(24);
      doc.setFont(undefined, 'bold');
      doc.text('Proposal', 20, 30);

      // Proposal details
      doc.setFontSize(12);
      doc.setFont(undefined, 'normal');
      
      let yPos = 50;
      const lineHeight = 8;
      
      // Basic info
      doc.setFont(undefined, 'bold');
      doc.text('Project:', 20, yPos);
      doc.setFont(undefined, 'normal');
      doc.text(proposal.project || 'N/A', 60, yPos);
      yPos += lineHeight;

      doc.setFont(undefined, 'bold');
      doc.text('Client:', 20, yPos);
      doc.setFont(undefined, 'normal');
      doc.text(proposal.client || 'N/A', 60, yPos);
      yPos += lineHeight;

      doc.setFont(undefined, 'bold');
      doc.text('Value:', 20, yPos);
      doc.setFont(undefined, 'normal');
      doc.text(proposal.value || 'N/A', 60, yPos);
      yPos += lineHeight;

      doc.setFont(undefined, 'bold');
      doc.text('Status:', 20, yPos);
      doc.setFont(undefined, 'normal');
      doc.text(proposal.status || 'N/A', 60, yPos);
      yPos += lineHeight;

      doc.setFont(undefined, 'bold');
      doc.text('Created:', 20, yPos);
      doc.setFont(undefined, 'normal');
      doc.text(proposal.created || proposal.date || 'N/A', 60, yPos);
      yPos += lineHeight * 2;

      // Description/Content
      if (proposal.description || proposal.content) {
        doc.setFont(undefined, 'bold');
        doc.text('Description:', 20, yPos);
        yPos += lineHeight;
        
        doc.setFont(undefined, 'normal');
        const content = proposal.description || proposal.content || '';
        const lines = doc.splitTextToSize(content, 170);
        lines.forEach(line => {
          doc.text(line, 20, yPos);
          yPos += lineHeight;
        });
        yPos += lineHeight;
      }

      // AI Insights if available
      if (proposal.aiAnalysis) {
        doc.setFont(undefined, 'bold');
        doc.text('AI Analysis:', 20, yPos);
        yPos += lineHeight;

        doc.setFont(undefined, 'normal');
        if (proposal.aiAnalysis.winProbability) {
          doc.text(`Win Probability: ${proposal.aiAnalysis.winProbability}%`, 20, yPos);
          yPos += lineHeight;
        }
        if (proposal.aiAnalysis.suggestedPricing) {
          doc.text(`Suggested Pricing: $${proposal.aiAnalysis.suggestedPricing.toLocaleString()}`, 20, yPos);
          yPos += lineHeight;
        }
        if (proposal.aiAnalysis.marketAnalysis) {
          doc.text('Market Analysis:', 20, yPos);
          yPos += lineHeight;
          const marketLines = doc.splitTextToSize(proposal.aiAnalysis.marketAnalysis, 170);
          marketLines.forEach(line => {
            doc.text(line, 20, yPos);
            yPos += lineHeight;
          });
        }
      }

      // Footer
      const pageHeight = doc.internal.pageSize.height;
      doc.setFontSize(8);
      doc.text('Generated by Conseccomms', 20, pageHeight - 20);
      doc.text(new Date().toLocaleDateString(), 20, pageHeight - 15);

      // Save the PDF
      const fileName = `proposal-${proposal.project?.replace(/\s+/g, '-') || 'export'}-${new Date().getTime()}.pdf`;
      doc.save(fileName);

      return { success: true, fileName };
    } catch (error) {
      console.error('PDF export error:', error);
      return { success: false, error: error.message };
    }
  },

  // Export proposals as CSV
  exportProposalsToCSV: async (proposals) => {
    try {
      const headers = [
        'ID',
        'Project',
        'Client',
        'Value',
        'Status',
        'Created',
        'Win Probability',
        'Suggested Pricing'
      ];

      const csvContent = [
        headers.join(','),
        ...proposals.map(proposal => [
          proposal.id || '',
          `"${(proposal.project || '').replace(/"/g, '""')}"`,
          `"${(proposal.client || '').replace(/"/g, '""')}"`,
          proposal.value || '',
          proposal.status || '',
          proposal.created || proposal.date || '',
          proposal.aiAnalysis?.winProbability || '',
          proposal.aiAnalysis?.suggestedPricing || ''
        ].join(','))
      ].join('\n');

      // Create and download the file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', `proposals-export-${new Date().getTime()}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      return { success: true };
    } catch (error) {
      console.error('CSV export error:', error);
      return { success: false, error: error.message };
    }
  },

  // Export sentiment report as PDF
  exportSentimentReportToPDF: async (sentimentReport) => {
    try {
      const { jsPDF } = await import('jspdf');
      const doc = new jsPDF();

      // Header
      doc.setFontSize(20);
      doc.setFont(undefined, 'bold');
      doc.text('Sentiment Analysis Report', 20, 30);

      // Report summary
      doc.setFontSize(12);
      doc.setFont(undefined, 'normal');
      let yPos = 50;

      doc.setFont(undefined, 'bold');
      doc.text('Summary', 20, yPos);
      yPos += 10;

      doc.setFont(undefined, 'normal');
      doc.text(`Total Feedback Analyzed: ${sentimentReport.summary.totalFeedback}`, 25, yPos);
      yPos += 8;
      doc.text(`Positive: ${sentimentReport.summary.sentimentDistribution.positive.percentage}% (${sentimentReport.summary.sentimentDistribution.positive.count})`, 25, yPos);
      yPos += 8;
      doc.text(`Negative: ${sentimentReport.summary.sentimentDistribution.negative.percentage}% (${sentimentReport.summary.sentimentDistribution.negative.count})`, 25, yPos);
      yPos += 8;
      doc.text(`Neutral: ${sentimentReport.summary.sentimentDistribution.neutral.percentage}% (${sentimentReport.summary.sentimentDistribution.neutral.count})`, 25, yPos);
      yPos += 8;
      doc.text(`Average Score: ${sentimentReport.summary.averageScore}`, 25, yPos);
      yPos += 15;

      // Insights
      if (sentimentReport.insights && sentimentReport.insights.length > 0) {
        doc.setFont(undefined, 'bold');
        doc.text('Key Insights', 20, yPos);
        yPos += 10;

        doc.setFont(undefined, 'normal');
        sentimentReport.insights.forEach((insight, index) => {
          const lines = doc.splitTextToSize(`• ${insight}`, 170);
          lines.forEach(line => {
            if (yPos > 250) {
              doc.addPage();
              yPos = 20;
            }
            doc.text(line, 25, yPos);
            yPos += 8;
          });
        });
        yPos += 10;
      }

      // Recommendations
      if (sentimentReport.recommendations && sentimentReport.recommendations.length > 0) {
        if (yPos > 200) {
          doc.addPage();
          yPos = 20;
        }
        
        doc.setFont(undefined, 'bold');
        doc.text('Recommendations', 20, yPos);
        yPos += 10;

        doc.setFont(undefined, 'normal');
        sentimentReport.recommendations.forEach((rec, index) => {
          const lines = doc.splitTextToSize(`• ${rec}`, 170);
          lines.forEach(line => {
            if (yPos > 250) {
              doc.addPage();
              yPos = 20;
            }
            doc.text(line, 25, yPos);
            yPos += 8;
          });
        });
      }

      // Footer
      const pageCount = doc.internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.text(`Generated by Conseccomms - Page ${i} of ${pageCount}`, 20, 285);
        doc.text(new Date().toLocaleDateString(), 170, 285);
      }

      const fileName = `sentiment-report-${new Date().getTime()}.pdf`;
      doc.save(fileName);

      return { success: true, fileName };
    } catch (error) {
      console.error('Sentiment PDF export error:', error);
      return { success: false, error: error.message };
    }
  },

  // Export admin reports as CSV
  exportReportToCSV: async (data, reportType, filename) => {
    try {
      let headers = [];
      let rows = [];

      switch (reportType) {
        case 'users':
          headers = ['ID', 'Name', 'Email', 'Role', 'Status', 'Created', 'Last Login'];
          rows = data.map(user => [
            user.id || '',
            `"${(user.first_name + ' ' + user.last_name).trim()}"`,
            user.email || '',
            user.role || '',
            user.status || '',
            user.created_at ? new Date(user.created_at).toLocaleDateString() : '',
            user.last_login ? new Date(user.last_login).toLocaleDateString() : ''
          ]);
          break;

        case 'files':
          headers = ['ID', 'Filename', 'Owner', 'Size (MB)', 'Type', 'Uploaded'];
          rows = data.map(file => [
            file.id || '',
            `"${(file.filename || '').replace(/"/g, '""')}"`,
            file.users ? `"${file.users.first_name} ${file.users.last_name}"` : '',
            file.file_size ? (file.file_size / 1024 / 1024).toFixed(2) : '',
            file.file_type || '',
            file.created_at ? new Date(file.created_at).toLocaleDateString() : ''
          ]);
          break;

        case 'feedback':
          headers = ['ID', 'User', 'Type', 'Subject', 'Priority', 'Status', 'Created'];
          rows = data.map(feedback => [
            feedback.id || '',
            feedback.user_name || '',
            feedback.type || '',
            `"${(feedback.subject || '').replace(/"/g, '""')}"`,
            feedback.priority || '',
            feedback.status || '',
            feedback.created_at ? new Date(feedback.created_at).toLocaleDateString() : ''
          ]);
          break;

        case 'leads':
          headers = ['ID', 'Name', 'Email', 'Company', 'Source', 'Status', 'Created'];
          rows = data.map(lead => [
            lead.id || '',
            `"${(lead.name || '').replace(/"/g, '""')}"`,
            lead.email || '',
            `"${(lead.company || '').replace(/"/g, '""')}"`,
            lead.source || '',
            lead.status || '',
            lead.created_at ? new Date(lead.created_at).toLocaleDateString() : ''
          ]);
          break;

        case 'user-activity':
          headers = [
            'User ID', 'Full Name', 'Email', 'Role', 'Subscription Plan', 'Account Created',
            'Last Login', 'Is New User', 'Total Activities', 'Active Days', 'Activity Level',
            'Engagement Score', 'Tickets Created', 'Files Uploaded', 'Proposals Created',
            'Login Sessions', 'Total Proposal Value', 'Average Proposal Value',
            'Storage Used (MB)', 'File Count', 'First Activity', 'Last Activity'
          ];
          rows = data.map(user => [
            user.userId || '',
            `"${(user.userFullName || '').replace(/"/g, '""')}"`,
            user.userEmail || '',
            user.role || '',
            user.subscriptionPlan || '',
            user.accountCreated ? new Date(user.accountCreated).toLocaleDateString() : '',
            user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never',
            user.isNewUser ? 'Yes' : 'No',
            user.totalActivities || 0,
            user.activeDays || 0,
            user.activityLevel || 'Inactive',
            user.engagementScore || 0,
            user.ticketsCreated || 0,
            user.filesUploaded || 0,
            user.proposalsCreated || 0,
            user.loginSessions || 0,
            user.totalProposalValue ? `$${user.totalProposalValue.toLocaleString()}` : '$0',
            user.averageProposalValue ? `$${user.averageProposalValue.toLocaleString()}` : '$0',
            user.totalStorageUsed ? (user.totalStorageUsed / 1024 / 1024).toFixed(2) : '0',
            user.fileCount || 0,
            user.firstActivity ? new Date(user.firstActivity).toLocaleDateString() : 'Never',
            user.lastActivity ? new Date(user.lastActivity).toLocaleDateString() : 'Never'
          ]);
          break;

        case 'financial':
          headers = [
            'User ID', 'Full Name', 'Email', 'Role', 'Subscription Plan', 'Account Created',
            'This Month Revenue', 'Last Month Revenue', 'Year to Date Revenue', 'Total Revenue',
            'This Month Proposals', 'Last Month Proposals', 'YTD Proposals', 'Total Proposals',
            'Draft Revenue', 'Sent Revenue', 'Accepted Revenue', 'Rejected Revenue',
            'Average Proposal Value', 'Conversion Rate (%)', 'Monthly Growth (%)',
            'Revenue Category', 'Top Performer', 'Growing User'
          ];
          rows = data.map(user => [
            user.userId || '',
            `"${(user.userFullName || '').replace(/"/g, '""')}"`,
            user.userEmail || '',
            user.role || '',
            user.subscriptionPlan || '',
            user.accountCreated ? new Date(user.accountCreated).toLocaleDateString() : '',
            user.thisMonthRevenue ? `$${user.thisMonthRevenue.toLocaleString()}` : '$0',
            user.lastMonthRevenue ? `$${user.lastMonthRevenue.toLocaleString()}` : '$0',
            user.yearToDateRevenue ? `$${user.yearToDateRevenue.toLocaleString()}` : '$0',
            user.totalRevenue ? `$${user.totalRevenue.toLocaleString()}` : '$0',
            user.thisMonthProposals || 0,
            user.lastMonthProposals || 0,
            user.yearToDateProposals || 0,
            user.totalProposals || 0,
            user.draftRevenue ? `$${user.draftRevenue.toLocaleString()}` : '$0',
            user.sentRevenue ? `$${user.sentRevenue.toLocaleString()}` : '$0',
            user.acceptedRevenue ? `$${user.acceptedRevenue.toLocaleString()}` : '$0',
            user.rejectedRevenue ? `$${user.rejectedRevenue.toLocaleString()}` : '$0',
            user.averageProposalValue ? `$${user.averageProposalValue.toLocaleString()}` : '$0',
            user.conversionRate ? user.conversionRate.toFixed(1) + '%' : '0%',
            user.monthlyGrowth ? user.monthlyGrowth.toFixed(1) + '%' : '0%',
            user.revenueCategory || 'No Revenue',
            user.isTopPerformer ? 'Yes' : 'No',
            user.isGrowing ? 'Yes' : 'No'
          ]);
          break;

        case 'simple-financial':
          headers = ['User Name', 'Email', 'Monthly Revenue'];
          rows = data.map(user => [
            `"${(user.userFullName || '').replace(/"/g, '""')}"`,
            user.userEmail || '',
            user.monthlyRevenue ? `$${user.monthlyRevenue.toLocaleString()}` : '$0'
          ]);
          break;

        default:
          headers = Object.keys(data[0] || {});
          rows = data.map(row => 
            headers.map(header => 
              typeof row[header] === 'string' 
                ? `"${row[header].replace(/"/g, '""')}"` 
                : row[header] || ''
            )
          );
      }

      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(','))
      ].join('\n');

      // Create and download the file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      const fileName = filename || `${reportType}-export-${new Date().getTime()}.csv`;
      link.setAttribute('href', url);
      link.setAttribute('download', fileName);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      URL.revokeObjectURL(url);

      return { success: true, fileName };
    } catch (error) {
      console.error('Report CSV export error:', error);
      return { success: false, error: error.message };
    }
  },

  // Export data as JSON
  exportToJSON: async (data, filename) => {
    try {
      const jsonContent = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      const fileName = filename || `data-export-${new Date().getTime()}.json`;
      link.setAttribute('href', url);
      link.setAttribute('download', fileName);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      URL.revokeObjectURL(url);

      return { success: true, fileName };
    } catch (error) {
      console.error('JSON export error:', error);
      return { success: false, error: error.message };
    }
  },

  // Get file extension based on export type
  getFileExtension: (exportType) => {
    const extensions = {
      'pdf': '.pdf',
      'csv': '.csv',
      'json': '.json',
      'xlsx': '.xlsx'
    };
    return extensions[exportType] || '.txt';
  },

  // Format file size for display
  formatFileSize: (bytes) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
};